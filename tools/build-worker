#!/bin/bash
# Build worker - runs builds independently in background
# Called by build-manager, survives parent shell exit

set -euo pipefail

# Read parameters
project_dir="$1"
project_key="$2"
build_command="$3"
log_file="$4"
session_id="$5"
sprint_file="$6"
task_id="$7"
description="$8"
git_metadata="$9"

CACHE_DIR="${HOME}/.cache/build-manager"
STATE_FILE="${CACHE_DIR}/state.json"
LOCK_FILE="${CACHE_DIR}/build.lock"

# CRITICAL: Acquire global lock for entire build duration
# This ensures only ONE build runs globally at a time
exec 200>"$LOCK_FILE"
if ! flock -x 200; then
    echo "ERROR: Failed to acquire global build lock" >&2
    exit 1
fi

# Lock is now held and will be automatically released when this script exits

# Setup ccache environment
# Prepend ccache bin to PATH so hipcc/gcc/g++/clang all go through ccache
# IMPORTANT: /opt/rocm/bin must come AFTER ccache bin so ccache can find real hipcc
export PATH="/usr/lib/ccache/bin:/opt/rocm/bin:$PATH"
# Use user's ccache directory (override system /var/cache/ccache from /etc/profile.d/ccache.sh)
export CCACHE_DIR="${HOME}/.ccache"
export CCACHE_MAXSIZE="50G"
export CCACHE_COMPRESS="1"
export CCACHE_COMPRESSLEVEL="1"
export CCACHE_BASEDIR="$project_dir"
# Set CC/CXX for builds that use them directly
export CC="ccache gcc"
export CXX="ccache g++"
# For CMake-based builds
export CMAKE_CXX_COMPILER_LAUNCHER=ccache
export CMAKE_C_COMPILER_LAUNCHER=ccache

# Normalize __FILE__ paths to enable ccache sharing across git worktrees
# Maps absolute project path to "." so __FILE__ expands to relative paths
export CFLAGS="${CFLAGS:-} -fmacro-prefix-map=${project_dir}=."
export CXXFLAGS="${CXXFLAGS:-} -fmacro-prefix-map=${project_dir}=."
export HIPFLAGS="${HIPFLAGS:-} -fmacro-prefix-map=${project_dir}=."

start_ts=$(date +%s)
exit_code=0

# Run the build
(
    cd "$project_dir"
    {
        echo "=== Build started at $(date) ==="
        echo "Project: $project_dir"
        echo "Session: $session_id"
        [[ -n "$sprint_file" ]] && echo "Sprint: $sprint_file"
        [[ -n "$task_id" ]] && echo "Task: $task_id"
        [[ -n "$description" ]] && echo "Description: $description"
        echo "Command: $build_command"
        echo "Using ccache: $CCACHE_DIR"
        echo "Macro prefix map: ${project_dir}=. (enables cross-worktree cache hits)"
        echo ""

        # Execute build command
        eval "$build_command" 2>&1
        exit_code=$?

        echo ""
        echo "=== Build finished at $(date) with exit code $exit_code ==="
        echo ""
        echo "=== ccache statistics ==="
        ccache -s 2>&1

        exit $exit_code
    } >> "$log_file" 2>&1
) || exit_code=$?

end_ts=$(date +%s)
duration=$((end_ts - start_ts))

# Format duration
duration_str=""
if [[ $duration -lt 60 ]]; then
    duration_str="${duration}s"
elif [[ $duration -lt 3600 ]]; then
    duration_str="$((duration / 60))m $((duration % 60))s"
else
    duration_str="$((duration / 3600))h $(( (duration % 3600) / 60))m"
fi

# Write completion marker (using jq for safe JSON escaping)
completion_marker="${CACHE_DIR}/completion.$(basename "$project_dir").$$"
jq -n \
    --arg project "$project_dir" \
    --argjson exit_code "$exit_code" \
    --argjson duration "$duration" \
    --arg session_id "$session_id" \
    --arg sprint_file "$sprint_file" \
    --arg task_id "$task_id" \
    --arg timestamp "$(date -Iseconds)" \
    --arg log_file "$log_file" \
    '{project: $project, exit_code: $exit_code, duration: $duration, session_id: $session_id, sprint_file: $sprint_file, task_id: $task_id, timestamp: $timestamp, log_file: $log_file}' \
    > "$completion_marker"

# Desktop notification
if command -v notify-send &>/dev/null 2>&1; then
    if [[ $exit_code -eq 0 ]]; then
        notify-send "Build Complete" "✓ $(basename "$project_dir") built successfully in $duration_str\nSession: $session_id" -u normal 2>/dev/null || true
    else
        notify-send "Build Failed" "✗ $(basename "$project_dir") failed after $duration_str\nSee: $log_file" -u critical 2>/dev/null || true
    fi
fi

# Add to history and clean up build state atomically
git_file="${STATE_FILE}.git.$$"
printf '%s' "$git_metadata" > "$git_file"

entry=$(jq -n \
    --arg pk "$project_key" \
    --arg cmd "$build_command" \
    --arg st "$([ $exit_code -eq 0 ] && echo 'success' || echo 'failed')" \
    --arg dur "$duration" \
    --arg ts "$(date -Iseconds)" \
    --arg session "$session_id" \
    --arg sprint "$sprint_file" \
    --arg task "$task_id" \
    --arg desc "$description" \
    --slurpfile git_data "$git_file" \
    '{project: $pk, command: $cmd, status: $st, duration: $dur, timestamp: $ts, session_id: $session, sprint_file: $sprint, task_id: $task, description: $desc, git: $git_data[0]}')

rm -f "$git_file"

# Atomic update: add to history AND remove from builds in single operation
(
    flock -x 200
    tmp_file="${STATE_FILE}.tmp.$$"
    jq ".history += [$entry] | .history |= (if length > 100 then .[1:] else . end) | del(.builds[\"$project_key\"])" "$STATE_FILE" > "$tmp_file"
    mv "$tmp_file" "$STATE_FILE"
) 200>"${STATE_FILE}.lock"

exit $exit_code
